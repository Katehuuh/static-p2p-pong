<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Rollback Pong (PeerJS)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { background: #111; color: #ddd; font-family: monospace; text-align: center; margin: 0; overflow: hidden; }
        canvas { background: #000; border: 2px solid #333; margin-top: 20px; }
        #ui-layer { position: absolute; top: 10px; left: 0; width: 100%; pointer-events: none; }
        .status-box { background: rgba(0,0,0,0.8); padding: 10px; display: inline-block; border: 1px solid #555; pointer-events: auto; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="status-box">
            <div id="status">Initializing Network...</div>
            <div id="stats" style="font-size: 0.8em; color: #888; margin-top: 5px;"></div>
        </div>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

<script>

/**
 * ============================================================================
 * MODULE 1: NETWORK MANAGER
 * Status: STABLE
 * ============================================================================
 */
class NetworkManager {
    constructor(prefix, onConnect, onData, onDisconnect) {
        this.prefix = prefix;
        this.roomIndex = 1;
        this.peer = null;
        this.conn = null;
        this.role = null; 
        this.onConnect = onConnect;
        this.onData = onData;
        this.onDisconnect = onDisconnect;
        this.isConnected = false;
        
        this.peerConfig = {
            debug: 1,
            config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }
        };
    }

    start() { this._attemptMatchmaking(); }

    send(data) {
        if (this.isConnected && this.conn) this.conn.send(data);
    }

    _attemptMatchmaking() {
        const hostID = `${this.prefix}room_${this.roomIndex}_host`;
        this._updateStatus(`Checking Room ${this.roomIndex}...`);

        const p = new Peer(hostID, this.peerConfig);

        p.on('error', (err) => {
            if (err.type === 'unavailable-id') {
                p.destroy();
                this._tryToJoin(hostID);
            } else {
                this._updateStatus("Network Error. Retrying...");
                setTimeout(() => this._attemptMatchmaking(), 2000);
            }
        });

        p.on('open', (id) => {
            this.peer = p;
            this.role = 'HOST';
            this._updateStatus(`Hosting Room ${this.roomIndex}. Waiting for player...`);
            p.on('connection', (conn) => this._setupConnection(conn));
        });
    }

    _tryToJoin(hostID) {
        const p = new Peer(null, this.peerConfig);
        p.on('open', (id) => {
            this.peer = p;
            this.role = 'JOINER';
            this._updateStatus(`Found Room ${this.roomIndex}. Connecting...`);
            
            const conn = p.connect(hostID, { reliable: true });
            const ghostTimeout = setTimeout(() => {
                if (!this.isConnected) {
                    conn.close(); p.destroy();
                    this.roomIndex++;
                    this._attemptMatchmaking();
                }
            }, 3000);

            conn.on('open', () => { clearTimeout(ghostTimeout); this._setupConnection(conn); });
            conn.on('error', () => { clearTimeout(ghostTimeout); this.roomIndex++; this._attemptMatchmaking(); });
        });
    }

    _setupConnection(conn) {
        this.conn = conn;
        this.isConnected = true;
        this._updateStatus(`Connected! Role: ${this.role}`);
        this.onConnect(this.role);
        conn.on('data', (data) => this.onData(data));
        conn.on('close', () => {
            this.isConnected = false;
            this.onDisconnect();
            setTimeout(() => location.reload(), 2000);
        });
    }

    _updateStatus(msg) { document.getElementById('status').innerText = msg; }
}

/**
 * ============================================================================
 * MODULE 2: ROLLBACK ENGINE (v4 - Integer Safety)
 * Status: STABLE
 * ============================================================================
 */
class RollbackEngine {
    constructor(gameInterface, networkManager) {
        this.game = gameInterface; 
        this.net = networkManager; 
        this.baseFrameRate = 60;
        this.frameLength = 1000 / this.baseFrameRate;
        
        this.frameCount = 0;
        this.localInputs = [];  
        this.remoteInputs = []; 
        this.states = [];       
        this.isRunning = false;
        this.playerIndex = 0; 
        
        this.lastTime = 0;
        this.accumulator = 0;

        // Drift Correction
        this.remoteFrameCount = 0;
        this.frameAdvantageStack = []; 
    }

    start(role) {
        this.playerIndex = (role === 'HOST') ? 0 : 1;
        this.isRunning = true;
        this.lastTime = performance.now();
        this.game.init(this.playerIndex);
        requestAnimationFrame((t) => this._loop(t));
    }

    onRemoteData(data) {
        this.remoteInputs[data.f] = data.i;
        this.remoteFrameCount = Math.max(this.remoteFrameCount, data.f);

        // Only rollback if we have history
        if (data.f < this.frameCount && this.states[data.f]) {
            this._performRollback(data.f);
        }

        const advantage = this.frameCount - data.f;
        this.frameAdvantageStack.push(advantage);
        if (this.frameAdvantageStack.length > 10) this.frameAdvantageStack.shift();
    }

    _loop(timestamp) {
        if (!this.isRunning) return;
        requestAnimationFrame((t) => this._loop(t));

        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;
        
        // Prevent spiral of death if tab is backgrounded (max 250ms jump)
        if (deltaTime > 250) {
            this.accumulator += 250;
        } else {
            this.accumulator += deltaTime;
        }

        let avgAdvantage = this._getAvgAdvantage();
        let currentFrameLength = this.frameLength;

        // Sync Speed (Drift Correction)
        if (avgAdvantage > 2) currentFrameLength *= 1.1; 
        else if (avgAdvantage < -2) currentFrameLength *= 0.9;

        while (this.accumulator >= currentFrameLength) {
            this._tick();
            this.accumulator -= currentFrameLength;
        }
        this.game.draw();
    }

    _tick() {
        const myInput = this.game.getLocalInput();
        this.localInputs[this.frameCount] = myInput;
        this.net.send({ f: this.frameCount, i: myInput });

        let opponentInput = this.remoteInputs[this.frameCount];
        if (opponentInput === undefined) {
            opponentInput = this._getLastKnownRemoteInput(this.frameCount);
        }

        // Memory Cleanup
        if (this.frameCount > 120) {
            delete this.states[this.frameCount - 120];
            delete this.localInputs[this.frameCount - 120];
            delete this.remoteInputs[this.frameCount - 120];
        }
        
        this.states[this.frameCount] = this.game.saveState();

        const inputs = this.playerIndex === 0 
            ? { p1: myInput, p2: opponentInput } 
            : { p1: opponentInput, p2: myInput };
        
        this.game.update(inputs);
        this.frameCount++;
    }

    _getLastKnownRemoteInput(currentFrame) {
        for (let i = currentFrame - 1; i >= 0; i--) {
            if (this.remoteInputs[i] !== undefined) return this.remoteInputs[i];
        }
        return this.game.getNeutralInput(); 
    }

    _performRollback(oldFrame) {
        const stateToRestore = this.states[oldFrame];
        if (!stateToRestore) return; 

        this.game.loadState(stateToRestore);

        for (let f = oldFrame; f < this.frameCount; f++) {
            const myInput = this.localInputs[f];
            let oppInput = this.remoteInputs[f];
            
            if (oppInput === undefined) oppInput = this._getLastKnownRemoteInput(f);

            const inputs = this.playerIndex === 0 
                ? { p1: myInput, p2: oppInput } 
                : { p1: oppInput, p2: myInput };

            this.game.update(inputs);
            this.states[f + 1] = this.game.saveState();
        }
    }

    _getAvgAdvantage() {
        if (this.frameAdvantageStack.length === 0) return 0;
        const sum = this.frameAdvantageStack.reduce((a, b) => a + b, 0);
        return sum / this.frameAdvantageStack.length;
    }
}

/**
 * ============================================================================
 * MODULE 3: PONG GAME (Integer Physics Fix)
 * Status: FIXED (Snap to Grid)
 * ============================================================================
 */
class PongGame {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.width = 800; this.height = 600;
        this.paddleH = 100; this.paddleW = 20; this.ballSize = 15;
        
        this.state = {
            p1y: 250, p2y: 250,
            bx: 400, by: 300,
            bvx: 5, bvy: 5,
            score1: 0, score2: 0,
            seed: 12345 
        };
        this.myRoleIndex = 0;
    }

    init(playerIndex) {
        this.myRoleIndex = playerIndex;
    }

    // Deterministic Random
    random() {
        this.state.seed = (this.state.seed + 0x6D2B79F5) | 0;
        let t = Math.imul(this.state.seed ^ (this.state.seed >>> 15), 1 | this.state.seed);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }

    getLocalInput() {
        // FIX: Round Input to Integer
        return Math.round(window.mouseY || 300);
    }

    getNeutralInput() { return 300; }

    update(inputs) {
        this.state.p1y = inputs.p1; 
        this.state.p2y = inputs.p2;

        const max = this.height - this.paddleH;
        this.state.p1y = Math.max(0, Math.min(max, this.state.p1y));
        this.state.p2y = Math.max(0, Math.min(max, this.state.p2y));

        this.state.bx += this.state.bvx;
        this.state.by += this.state.bvy;

        // FIX: Snap Ball to Integer Positions for Collision Checks
        // This prevents Floating Point drifts causing desync on rollback
        let bx_int = Math.round(this.state.bx);
        let by_int = Math.round(this.state.by);

        // Walls
        if (by_int <= 0 || by_int >= this.height - this.ballSize) {
            this.state.bvy *= -1;
        }

        // Paddles (Using Integer Logic)
        if (bx_int <= 30 && by_int + this.ballSize > this.state.p1y && by_int < this.state.p1y + this.paddleH) {
            this.state.bvx = Math.abs(this.state.bvx); 
        }
        if (bx_int >= 770 - this.ballSize && by_int + this.ballSize > this.state.p2y && by_int < this.state.p2y + this.paddleH) {
            this.state.bvx = -Math.abs(this.state.bvx);
        }

        // Scoring
        if (bx_int < 0) {
            this.state.score2++;
            this._resetBall();
        }
        if (bx_int > this.width) {
            this.state.score1++;
            this._resetBall();
        }
    }

    _resetBall() {
        this.state.bx = 400;
        this.state.by = 300;
        this.state.bvx = (this.random() > 0.5 ? 5 : -5);
        this.state.bvy = (this.random() > 0.5 ? 3 : -3);
    }

    draw() {
        this.ctx.fillStyle = "#000";
        this.ctx.fillRect(0, 0, this.width, this.height);
        this.ctx.fillStyle = "white";
        this.ctx.fillRect(10, this.state.p1y, this.paddleW, this.paddleH);
        this.ctx.fillRect(770, this.state.p2y, this.paddleW, this.paddleH);
        this.ctx.fillRect(this.state.bx, this.state.by, this.ballSize, this.ballSize);
        this.ctx.font = "30px monospace";
        this.ctx.fillText(this.state.score1, 200, 50);
        this.ctx.fillText(this.state.score2, 600, 50);
        this.ctx.fillStyle = "yellow";
        this.ctx.font = "12px monospace";
        this.ctx.fillText(this.myRoleIndex === 0 ? "YOU" : "OPP", 10, this.state.p1y - 5);
        this.ctx.fillText(this.myRoleIndex === 1 ? "YOU" : "OPP", 770, this.state.p2y - 5);
    }

    saveState() { return JSON.parse(JSON.stringify(this.state)); }
    loadState(s) { this.state = JSON.parse(JSON.stringify(s)); }
}

// ==========================================================
// MAIN
// ==========================================================
window.mouseY = 300;
document.addEventListener('mousemove', e => {
    const rect = document.getElementById('gameCanvas').getBoundingClientRect();
    window.mouseY = e.clientY - rect.top - 50; 
});

const game = new PongGame('gameCanvas');
const net = new NetworkManager("pong_v11_", 
    (role) => engine.start(role),
    (data) => engine.onRemoteData(data),
    () => console.log("Disconnected")
);
const engine = new RollbackEngine(game, net);
net.start();

</script>
</body>
</html>
